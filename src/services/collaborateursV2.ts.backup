import { 
  ref as rtdbRef, 
  get, 
  set,
  update,
  query as rtdbQuery,
  orderByChild,
  orderByKey,
  equalTo,
  push,
  remove,
  onValue,
  off,
  type Unsubscribe
} from 'firebase/database'
import { rtdb } from './firebase'
import type { 
  CollaborateurV2, 
  DisponibiliteV2, 
  PlanningDataV2,
  BatchUpdateV2,
  ImportDataV2,
  MigrationResult,
  StatsCollaborateurV2
} from '../types/optimized-v2'

/**
 * Service optimis√© V2 - Structure centr√©e sur les collaborateurs
 * Architecture Firestore :
 * /tenants/{tenantId}/collaborateurs/{collaborateurId}
 * /tenants/{tenantId}/collaborateurs/{collaborateurId}/disponibilites/{date}
 */
export class CollaborateursServiceV2 {
  
  /**
   * Charger tous les collaborateurs d'un tenant depuis RTDB
   */
  static async loadCollaborateursFromRTDB(tenantId: string): Promise<CollaborateurV2[]> {
    try {
      const collaborateursRef = rtdbRef(rtdb, `tenants/${tenantId}/collaborateurs`)
      const snapshot = await get(collaborateursRef)
      
      if (!snapshot.exists()) {
        return []
      }
      
      const data = snapshot.val()
      const collaborateurs: CollaborateurV2[] = []
      
      Object.entries(data).forEach(([id, collabData]: [string, any]) => {
        collaborateurs.push({
          id,
          nom: collabData.nom,
          prenom: collabData.prenom,
          metier: collabData.metier,
          note: collabData.note || '',
          email: collabData.email || '',
          phone: collabData.phone || '',
          color: collabData.color || null,
          tenantId: collabData.tenantId,
          actif: collabData.actif !== false,
          createdAt: new Date(collabData.createdAt || Date.now()),
          updatedAt: new Date(collabData.updatedAt || Date.now()),
          // Champs optionnels rapports √† l'inscription
          ...(collabData.registrationCode ? { registrationCode: collabData.registrationCode } : {}),
          ...(collabData.registrationStatus ? { registrationStatus: collabData.registrationStatus } : {}),
          ...(collabData.registrationExpiresAt ? { registrationExpiresAt: collabData.registrationExpiresAt } : {}),
          ...(collabData.userId ? { userId: collabData.userId } : {})
        } as CollaborateurV2)
      })
      
      // Trier par nom puis pr√©nom
      collaborateurs.sort((a, b) => {
        if (a.nom !== b.nom) return a.nom.localeCompare(b.nom)
        return a.prenom.localeCompare(b.prenom)
      })
      
      return collaborateurs
      
    } catch (error) {
      console.error('‚ùå Erreur chargement collaborateurs RTDB:', error)
      return []
    }
  }
  
  /**
   * Charger tous les collaborateurs d'un tenant (alias pour loadCollaborateursFromRTDB)
   */
  static async loadCollaborateursFromImport(tenantId: string): Promise<CollaborateurV2[]> {
    return this.loadCollaborateursFromRTDB(tenantId)
  }

  /**
   * Charger tous les collaborateurs d'un tenant
   */
  static async loadCollaborateurs(tenantId: string): Promise<CollaborateurV2[]> {
    try {
      const collaborateursRef = rtdbRef(rtdb, `tenants/${tenantId}/collaborateurs`)
      const snapshot = await get(collaborateursRef)
      
      if (!snapshot.exists()) {
        return []
      }
      
      const data = snapshot.val()
      const collaborateurs: CollaborateurV2[] = []
      
      Object.entries(data).forEach(([id, collabData]: [string, any]) => {
        // Filtrer seulement les collaborateurs actifs
        if (collabData.actif !== false) {
          collaborateurs.push({
            id,
            nom: collabData.nom,
            prenom: collabData.prenom,
            metier: collabData.metier,
            note: collabData.note || '',
            email: collabData.email || '',
            phone: collabData.phone || '',
            color: collabData.color || null,
            tenantId: collabData.tenantId,
            actif: collabData.actif !== false,
            createdAt: new Date(collabData.createdAt || Date.now()),
            updatedAt: new Date(collabData.updatedAt || Date.now()),
            version: collabData.version || 1,
            updatedBy: collabData.updatedBy || ''
          } as CollaborateurV2)
        }
      })
      
      // Trier par nom puis pr√©nom
      collaborateurs.sort((a, b) => {
        if (a.nom !== b.nom) return a.nom.localeCompare(b.nom)
        return a.prenom.localeCompare(b.prenom)
      })
      
      return collaborateurs
      
    } catch (error) {
      console.error('‚ùå Erreur chargement collaborateurs:', error)
      throw error
    }
  }

  /**
   * R√©cup√©rer un collaborateur par son ID
   */
  /**
   * R√©cup√©rer un collaborateur par ID depuis RTDB
   */
  static async getCollaborateurFromRTDB(tenantId: string, collaborateurId: string): Promise<CollaborateurV2 | null> {
    try {
      console.log('üîÑ Recherche collaborateur RTDB:', collaborateurId)
      
      const collaborateurRef = rtdbRef(rtdb, `tenants/${tenantId}/collaborateurs/${collaborateurId}`)
      const snapshot = await rtdbGet(collaborateurRef)
      
      if (!snapshot.exists()) {
        console.log('‚ùå Collaborateur introuvable dans RTDB:', collaborateurId)
        return null
      }
      
      const data = snapshot.val()
      
      return {
        id: collaborateurId,
        nom: data.nom,
        prenom: data.prenom,
        metier: data.metier,
        note: data.note || '',
        email: data.email || '',
        phone: data.phone || '',
        color: data.color || null,
        tenantId: data.tenantId,
        actif: data.actif !== false,
  createdAt: new Date(data.createdAt || Date.now()),
  updatedAt: new Date(data.updatedAt || Date.now()),
  ...(data.registrationCode ? { registrationCode: data.registrationCode } : {}),
  ...(data.registrationStatus ? { registrationStatus: data.registrationStatus } : {}),
  ...(data.registrationExpiresAt ? { registrationExpiresAt: data.registrationExpiresAt } : {}),
  ...(data.userId ? { userId: data.userId } : {})
      } as CollaborateurV2
      
    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration collaborateur RTDB:', error)
      throw error
    }
  }

  /**
   * R√©cup√©rer un collaborateur par ID (Firestore)
   */
  static async getCollaborateur(tenantId: string, collaborateurId: string): Promise<CollaborateurV2 | null> {
    try {
      // Essayer RTDB d'abord
      const rtdbCollaborateur = await this.getCollaborateurFromRTDB(tenantId, collaborateurId)
      if (rtdbCollaborateur) {
        return rtdbCollaborateur
      }
      
      // Fallback vers Firestore
      console.log('üîÑ Fallback Firestore pour collaborateur:', collaborateurId)
      const collaborateurRef = doc(db, `tenants/${tenantId}/collaborateurs/${collaborateurId}`)
      const collaborateurDoc = await getDoc(collaborateurRef)
      
      if (!collaborateurDoc.exists()) {
        console.log('‚ùå Collaborateur introuvable:', collaborateurId)
        return null
      }
      
      const data = collaborateurDoc.data()
      
      return {
        id: collaborateurDoc.id,
        ...data,
        createdAt: data.createdAt?.toDate?.() || new Date(),
        updatedAt: data.updatedAt?.toDate?.() || new Date()
      } as CollaborateurV2
      
    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration collaborateur:', error)
      throw error
    }
  }

  /**
   * Cr√©er un nouveau collaborateur
   */
  static async createCollaborateur(
    tenantId: string, 
    data: Omit<CollaborateurV2, 'id' | 'createdAt' | 'updatedAt' | 'version' | 'updatedBy'>,
    userId: string
  ): Promise<string> {
    try {
      const collaborateurRef = doc(collection(db, `tenants/${tenantId}/collaborateurs`))
      
      const collaborateurData: Omit<CollaborateurV2, 'id'> = {
        ...data,
        tenantId,
        actif: true,
        createdAt: new Date(),
        updatedAt: new Date(),
        updatedBy: userId,
        version: 1
      }
      
      await setDoc(collaborateurRef, {
        ...collaborateurData,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      })
      
      // √âcriture en miroir dans RTDB pour que la liste (qui lit RTDB) voie imm√©diatement le nouveau collaborateur
      try {
        const rtdbPath = `tenants/${tenantId}/collaborateurs/${collaborateurRef.id}`
        await rtdbUpdate(rtdbRef(rtdb, rtdbPath), {
          nom: data.nom,
          prenom: data.prenom,
          metier: data.metier,
          note: (data as any).note || '',
          email: (data as any).email || '',
          phone: (data as any).phone || '',
          color: (data as any).color || null,
          tenantId,
          actif: true,
          createdAt: Date.now(),
          updatedAt: Date.now(),
          updatedBy: userId,
          version: 1
        })
        console.log('‚úÖ Collaborateur √©crit dans RTDB:', rtdbPath)
      } catch (rtdbErr) {
        console.warn('‚ö†Ô∏è √âchec √©criture RTDB (cr√©ation collaborateur):', rtdbErr)
      }

      console.log('‚úÖ Collaborateur cr√©√©:', collaborateurRef.id)
      return collaborateurRef.id
      
    } catch (error) {
      console.error('‚ùå Erreur cr√©ation collaborateur:', error)
      throw error
    }
  }

  /**
   * Mettre √† jour un collaborateur
   */
  static async updateCollaborateur(
    tenantId: string,
    collaborateurId: string,
    data: Partial<CollaborateurV2>,
    userId: string
  ): Promise<void> {
    try {
      // Essayer de mettre √† jour dans RTDB d'abord
      const rtdbCollaborateurRef = rtdbRef(rtdb, `tenants/${tenantId}/collaborateurs/${collaborateurId}`)
      const rtdbSnapshot = await rtdbGet(rtdbCollaborateurRef)
      
      if (rtdbSnapshot.exists()) {
        console.log('üîÑ Mise √† jour collaborateur RTDB:', collaborateurId)
        console.log('üìã Donn√©es √† mettre √† jour:', data)
        // Mettre √† jour dans RTDB
        const updateData = {
          ...data,
          updatedAt: Date.now(),
          updatedBy: userId
        }
        console.log('üìã Donn√©es finales envoy√©es:', updateData)
        await rtdbUpdate(rtdbCollaborateurRef, updateData)
        console.log('‚úÖ Collaborateur mis √† jour dans RTDB:', collaborateurId)
        return
      }
      
      // Fallback vers Firestore si pas trouv√© dans RTDB
      console.log('üîÑ Fallback Firestore pour mise √† jour collaborateur:', collaborateurId)
      const collaborateurRef = doc(db, `tenants/${tenantId}/collaborateurs/${collaborateurId}`)
      
      await runTransaction(db, async (transaction) => {
        const collaborateurDoc = await transaction.get(collaborateurRef)
        
        if (!collaborateurDoc.exists()) {
          throw new Error('Collaborateur introuvable')
        }
        
        const currentData = collaborateurDoc.data() as CollaborateurV2
        const newVersion = currentData.version + 1
        
        transaction.update(collaborateurRef, {
          ...data,
          updatedAt: serverTimestamp(),
          updatedBy: userId,
          version: newVersion
        })
      })
      
      console.log('‚úÖ Collaborateur mis √† jour dans Firestore:', collaborateurId)
      
    } catch (error) {
      console.error('‚ùå Erreur mise √† jour collaborateur:', error)
      throw error
    }
  }

  /**
   * Supprimer un collaborateur (soft delete)
   */
  static async deleteCollaborateur(
    tenantId: string,
    collaborateurId: string,
    userId: string
  ): Promise<void> {
    try {
      // Essayer de supprimer dans RTDB d'abord
      const rtdbCollaborateurRef = rtdbRef(rtdb, `tenants/${tenantId}/collaborateurs/${collaborateurId}`)
      const rtdbSnapshot = await rtdbGet(rtdbCollaborateurRef)
      
      if (rtdbSnapshot.exists()) {
        console.log('üîÑ Suppression collaborateur RTDB:', collaborateurId)
        // Soft delete dans RTDB
        await rtdbUpdate(rtdbCollaborateurRef, {
          actif: false,
          updatedAt: Date.now(),
          updatedBy: userId
        })
        console.log('‚úÖ Collaborateur supprim√© (soft) dans RTDB:', collaborateurId)
        return
      }
      
      // Fallback vers Firestore si pas trouv√© dans RTDB
      console.log('üîÑ Fallback Firestore pour suppression collaborateur:', collaborateurId)
      const collaborateurRef = doc(db, `tenants/${tenantId}/collaborateurs/${collaborateurId}`)
      
      await updateDoc(collaborateurRef, {
        actif: false,
        updatedAt: serverTimestamp(),
        updatedBy: userId,
        version: (await getDoc(collaborateurRef)).data()?.version + 1 || 1
      })
      
      console.log('‚úÖ Collaborateur supprim√© (soft) dans Firestore:', collaborateurId)
      
    } catch (error) {
      console.error('‚ùå Erreur suppression collaborateur:', error)
      throw error
    }
  }

  /**
   * Charger les disponibilit√©s d'un collaborateur pour une p√©riode
   */
  static async loadDisponibilites(
    tenantId: string,
    collaborateurId: string,
    dateDebut: string,
    dateFin: string
  ): Promise<Map<string, DisponibiliteV2>> {
    try {
      console.log(`üîÑ Chargement disponibilit√©s ${collaborateurId} du ${dateDebut} au ${dateFin}`)
      
      const disposRef = collection(db, `tenants/${tenantId}/collaborateurs/${collaborateurId}/disponibilites`)
      const q = query(
        disposRef, 
        where('__name__', '>=', dateDebut),
        where('__name__', '<=', dateFin),
        orderBy('__name__')
      )
      
      const snapshot = await getDocs(q)
      const disponibilites = new Map<string, DisponibiliteV2>()
      
      snapshot.forEach((doc) => {
        const data = doc.data()
        disponibilites.set(doc.id, {
          date: doc.id,
          ...data,
          updatedAt: data.updatedAt?.toDate?.() || new Date()
        } as DisponibiliteV2)
      })
      
      console.log(`‚úÖ ${disponibilites.size} disponibilit√©s charg√©es`)
      return disponibilites
      
    } catch (error) {
      console.error('‚ùå Erreur chargement disponibilit√©s:', error)
      throw error
    }
  }

  /**
   * Mettre √† jour une disponibilit√©
   */
  static async updateDisponibilite(
    tenantId: string,
    collaborateurId: string,
    date: string,
    data: Omit<DisponibiliteV2, 'date'>,
    userId: string
  ): Promise<void> {
    try {
      const dispoRef = doc(db, `tenants/${tenantId}/collaborateurs/${collaborateurId}/disponibilites/${date}`)
      
      await runTransaction(db, async (transaction) => {
        const dispoDoc = await transaction.get(dispoRef)
        const currentVersion = dispoDoc.exists() ? dispoDoc.data()?.version || 0 : 0
        
        transaction.set(dispoRef, {
          date,
          ...data,
          updatedAt: serverTimestamp(),
          updatedBy: userId,
          version: currentVersion + 1
        })
      })
      
      console.log(`‚úÖ Disponibilit√© mise √† jour: ${collaborateurId}/${date}`)
      
    } catch (error) {
      console.error('‚ùå Erreur mise √† jour disponibilit√©:', error)
      throw error
    }
  }

  /**
   * Mise √† jour en lot de disponibilit√©s
   */
  static async batchUpdateDisponibilites(
    tenantId: string,
    updates: BatchUpdateV2[],
    userId: string
  ): Promise<void> {
    try {
      console.log(`üîÑ Mise √† jour en lot de ${updates.length} collaborateurs`)
      
      const batch = writeBatch(db)
      let operationsCount = 0
      
      for (const update of updates) {
        for (const dispoUpdate of update.updates) {
          const dispoRef = doc(
            db, 
            `tenants/${tenantId}/collaborateurs/${update.collaborateurId}/disponibilites/${dispoUpdate.date}`
          )
          
          batch.set(dispoRef, {
            date: dispoUpdate.date,
            creneaux: dispoUpdate.creneaux,
            updatedAt: serverTimestamp(),
            updatedBy: userId,
            version: 1 // On pourrait r√©cup√©rer la version actuelle, mais pour l'import c'est OK
          })
          
          operationsCount++
          
          // Firestore limite √† 500 op√©rations par batch
          if (operationsCount >= 450) {
            await batch.commit()
            console.log(`‚úÖ Batch de ${operationsCount} op√©rations ex√©cut√©`)
            operationsCount = 0
          }
        }
      }
      
      if (operationsCount > 0) {
        await batch.commit()
        console.log(`‚úÖ Batch final de ${operationsCount} op√©rations ex√©cut√©`)
      }
      
      console.log('‚úÖ Mise √† jour en lot termin√©e')
      
    } catch (error) {
      console.error('‚ùå Erreur mise √† jour en lot:', error)
      throw error
    }
  }

  /**
   * Charger le planning complet pour une p√©riode
   */
  static async loadPlanning(
    tenantId: string,
    dateDebut: string,
    dateFin: string
  ): Promise<PlanningDataV2> {
    try {
      console.log(`üîÑ Chargement planning complet du ${dateDebut} au ${dateFin}`)
      
      // 1. Charger tous les collaborateurs
      const collaborateurs = await this.loadCollaborateurs(tenantId)
      
      // 2. Charger les disponibilit√©s en parall√®le
      const disponibilitesPromises = collaborateurs.map(async (collaborateur) => {
        const dispos = await this.loadDisponibilites(tenantId, collaborateur.id!, dateDebut, dateFin)
        return { collaborateurId: collaborateur.id!, disponibilites: dispos }
      })
      
      const disponibilitesResults = await Promise.all(disponibilitesPromises)
      
      // 3. Organiser les donn√©es
      const disponibilitesMap = new Map<string, Map<string, DisponibiliteV2>>()
      let totalDisponibilites = 0
      
      disponibilitesResults.forEach(({ collaborateurId, disponibilites }) => {
        disponibilitesMap.set(collaborateurId, disponibilites)
        totalDisponibilites += disponibilites.size
      })
      
      const planningData: PlanningDataV2 = {
        collaborateurs,
        disponibilitesByCollaborateur: disponibilitesMap,
        dateRange: { debut: dateDebut, fin: dateFin },
        totalCollaborateurs: collaborateurs.length,
        totalDisponibilites
      }
      
      console.log(`‚úÖ Planning charg√©: ${collaborateurs.length} collaborateurs, ${totalDisponibilites} disponibilit√©s`)
      return planningData
      
    } catch (error) {
      console.error('‚ùå Erreur chargement planning:', error)
      throw error
    }
  }

  /**
   * S'abonner aux changements temps r√©el d'un collaborateur
   */
  static subscribeToCollaborateurChanges(
    tenantId: string,
    collaborateurId: string,
    callback: (collaborateur: CollaborateurV2 | null) => void
  ): Unsubscribe {
    const collaborateurRef = doc(db, `tenants/${tenantId}/collaborateurs/${collaborateurId}`)
    
    return onSnapshot(collaborateurRef, (doc) => {
      if (doc.exists()) {
        const data = doc.data()
        callback({
          id: doc.id,
          ...data,
          createdAt: data.createdAt?.toDate?.() || new Date(),
          updatedAt: data.updatedAt?.toDate?.() || new Date()
        } as CollaborateurV2)
      } else {
        callback(null)
      }
    })
  }

  /**
   * S'abonner aux changements temps r√©el des disponibilit√©s
   */
  static subscribeToDisponibilitesChanges(
    tenantId: string,
    collaborateurId: string,
    dateDebut: string,
    dateFin: string,
    callback: (disponibilites: Map<string, DisponibiliteV2>) => void
  ): Unsubscribe {
    const disposRef = collection(db, `tenants/${tenantId}/collaborateurs/${collaborateurId}/disponibilites`)
    const q = query(
      disposRef,
      where('__name__', '>=', dateDebut),
      where('__name__', '<=', dateFin),
      orderBy('__name__')
    )
    
    return onSnapshot(q, (snapshot) => {
      const disponibilites = new Map<string, DisponibiliteV2>()
      
      snapshot.forEach((doc) => {
        const data = doc.data()
        disponibilites.set(doc.id, {
          date: doc.id,
          ...data,
          updatedAt: data.updatedAt?.toDate?.() || new Date()
        } as DisponibiliteV2)
      })
      
      callback(disponibilites)
    })
  }

  /**
   * Import en lot depuis Excel avec la nouvelle structure
   */
  static async importFromExcel(
    tenantId: string,
    data: ImportDataV2[],
    userId: string
  ): Promise<MigrationResult> {
    const startTime = Date.now()
    const result: MigrationResult = {
      collaborateursCreated: 0,
      disponibilitesCreated: 0,
      erreurs: [],
      duree: 0
    }
    
    try {
      console.log(`üîÑ Import Excel: ${data.length} entr√©es √† traiter`)
      
      // Grouper par collaborateur
      const collaborateursMap = new Map<string, {
        info: Omit<CollaborateurV2, 'id' | 'createdAt' | 'updatedAt' | 'version' | 'updatedBy'>
        disponibilites: Array<{
          date: string
          lieu: string | null
          heure_debut: string | null
          heure_fin: string | null
          statut: 'disponible' | 'indisponible' | 'affecte'
        }>
      }>()
      
      for (const item of data) {
        const key = `${item.collaborateur.nom}-${item.collaborateur.prenom}`
        
        if (!collaborateursMap.has(key)) {
          collaborateursMap.set(key, {
            info: item.collaborateur,
            disponibilites: []
          })
        }
        
        // Convertir les disponibilit√©s avec statut par d√©faut
        const disponibilitesAvecStatut = item.disponibilites.map(dispo => ({
          ...dispo,
          statut: dispo.statut || 'disponible' as const
        }))
        
        collaborateursMap.get(key)!.disponibilites.push(...disponibilitesAvecStatut)
      }
      
      // Traiter chaque collaborateur
      for (const [key, collabData] of collaborateursMap) {
        try {
          // V√©rifier si le collaborateur existe d√©j√†
          const existingCollabs = await this.loadCollaborateurs(tenantId)
          let collaborateur = existingCollabs.find(c => 
            c.nom === collabData.info.nom && c.prenom === collabData.info.prenom
          )
          
          if (!collaborateur) {
            // Cr√©er nouveau collaborateur
            const collaborateurId = await this.createCollaborateur(tenantId, collabData.info, userId)
            result.collaborateursCreated++
            
            // Pr√©parer les disponibilit√©s
            const updates: BatchUpdateV2 = {
              collaborateurId,
              updates: []
            }
            
            // Grouper les disponibilit√©s par date
            const disposParDate = new Map<string, DisponibiliteV2['creneaux']>()
            
            for (const dispo of collabData.disponibilites) {
              if (!disposParDate.has(dispo.date)) {
                disposParDate.set(dispo.date, [])
              }
              
              disposParDate.get(dispo.date)!.push({
                lieu: dispo.lieu,
                heure_debut: dispo.heure_debut,
                heure_fin: dispo.heure_fin,
                statut: dispo.statut || 'disponible'
              })
            }
            
            // Convertir en format BatchUpdate
            for (const [date, creneaux] of disposParDate) {
              updates.updates.push({ date, creneaux })
            }
            
            await this.batchUpdateDisponibilites(tenantId, [updates], userId)
            result.disponibilitesCreated += updates.updates.length
            
          } else {
            console.log(`‚ÑπÔ∏è Collaborateur existant: ${key}`)
            // Ici on pourrait mettre √† jour les disponibilit√©s existantes
          }
          
        } catch (error) {
          result.erreurs.push({
            type: 'collaborateur',
            data: collabData,
            error: error instanceof Error ? error.message : String(error)
          })
        }
      }
      
      result.duree = Date.now() - startTime
      console.log(`‚úÖ Import termin√© en ${result.duree}ms:`, result)
      return result
      
    } catch (error) {
      console.error('‚ùå Erreur import Excel:', error)
      result.duree = Date.now() - startTime
      throw error
    }
  }

  /**
   * G√©n√©rer des statistiques pour un collaborateur
   */
  static async getStatsCollaborateur(
    tenantId: string,
    collaborateurId: string,
    dateDebut: string,
    dateFin: string
  ): Promise<StatsCollaborateurV2> {
    try {
      const collaborateur = await getDoc(doc(db, `tenants/${tenantId}/collaborateurs/${collaborateurId}`))
      if (!collaborateur.exists()) {
        throw new Error('Collaborateur introuvable')
      }
      
      const collabData = collaborateur.data() as CollaborateurV2
      const disponibilites = await this.loadDisponibilites(tenantId, collaborateurId, dateDebut, dateFin)
      
      let joursDisponibles = 0
      let joursIndisponibles = 0
      let joursAffectes = 0
      
      disponibilites.forEach((dispo) => {
        dispo.creneaux.forEach((creneau) => {
          switch (creneau.statut) {
            case 'disponible': joursDisponibles++; break
            case 'indisponible': joursIndisponibles++; break
            case 'affecte': joursAffectes++; break
          }
        })
      })
      
      const totalJours = joursDisponibles + joursIndisponibles + joursAffectes
      
      return {
        collaborateurId,
        nom: collabData.nom,
        prenom: collabData.prenom,
        totalDisponibilites: disponibilites.size,
        joursDisponibles,
        joursIndisponibles,
        joursAffectes,
        tauxDisponibilite: totalJours > 0 ? (joursDisponibles / totalJours) * 100 : 0,
        derniereMiseAJour: collabData.updatedAt
      }
      
    } catch (error) {
      console.error('‚ùå Erreur stats collaborateur:', error)
      throw error
    }
  }

  /**
   * Vider toutes les donn√©es d'un tenant (collaborateurs et disponibilit√©s)
   * Utilis√© avant un import complet pour √©viter les doublons
   */
  static async clearTenantData(tenantId: string): Promise<{ deletedCollaborateurs: number, deletedDisponibilites: number }> {
    try {
      console.log(`üóëÔ∏è Suppression de toutes les donn√©es du tenant: ${tenantId}`)
      
      const collaborateursRef = collection(db, `tenants/${tenantId}/collaborateurs`)
      const collaborateursQuery = query(
        collaborateursRef, 
        orderBy('nom'),
        limit(30) // OPTIMISATION URGENTE: Limiter √† 30 collaborateurs
      )
      const collaborateursSnapshot = await getDocs(collaborateursQuery)
      
      let deletedCollaborateurs = 0
      let deletedDisponibilites = 0
      
      // Supprimer tous les collaborateurs et leurs sous-collections
      const batch = writeBatch(db)
      
      for (const collabDoc of collaborateursSnapshot.docs) {
        const collaborateurId = collabDoc.id
        
        // Supprimer toutes les disponibilit√©s de ce collaborateur
        const disponibilitesRef = collection(db, `tenants/${tenantId}/collaborateurs/${collaborateurId}/disponibilites`)
        const disponibilitesSnapshot = await getDocs(disponibilitesRef)
        
        for (const dispoDoc of disponibilitesSnapshot.docs) {
          batch.delete(dispoDoc.ref)
          deletedDisponibilites++
        }
        
        // Supprimer le collaborateur
        batch.delete(collabDoc.ref)
        deletedCollaborateurs++
      }
      
      await batch.commit()
      
      console.log(`‚úÖ Suppression termin√©e: ${deletedCollaborateurs} collaborateurs, ${deletedDisponibilites} disponibilit√©s`)
      return { deletedCollaborateurs, deletedDisponibilites }
      
    } catch (error) {
      console.error('‚ùå Erreur suppression donn√©es tenant:', error)
      throw error
    }
  }
}

// Instance singleton du service
export const collaborateursServiceV2 = new CollaborateursServiceV2()
